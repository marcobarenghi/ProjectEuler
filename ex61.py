#<p>Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:</p>
#<table><tr><td>Triangle</td>
#<td> </td>
#<td>$P_{3,n}=n(n+1)/2$</td>
#<td> </td>
#<td>$1, 3, 6, 10, 15, \dots$</td>
#</tr><tr><td>Square</td>
#<td> </td>
#<td>$P_{4,n}=n^2$</td>
#<td> </td>
#<td>$1, 4, 9, 16, 25, \dots$</td>
#</tr><tr><td>Pentagonal</td>
#<td> </td>
#<td>$P_{5,n}=n(3n-1)/2$</td>
#<td> </td>
#<td>$1, 5, 12, 22, 35, \dots$</td>
#</tr><tr><td>Hexagonal</td>
#<td> </td>
#<td>$P_{6,n}=n(2n-1)$</td>
#<td> </td>
#<td>$1, 6, 15, 28, 45, \dots$</td>
#</tr><tr><td>Heptagonal</td>
#<td> </td>
#<td>$P_{7,n}=n(5n-3)/2$</td>
#<td> </td>
#<td>$1, 7, 18, 34, 55, \dots$</td>
#</tr><tr><td>Octagonal</td>
#<td> </td>
#<td>$P_{8,n}=n(3n-2)$</td>
#<td> </td>
#<td>$1, 8, 21, 40, 65, \dots$</td>
#</tr></table><p>The ordered set of three $4$-digit numbers: $8128$, $2882$, $8281$, has three interesting properties.</p>
#<ol><li>The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).</li>
#<li>Each polygonal type: triangle ($P_{3,127}=8128$), square ($P_{4,91}=8281$), and pentagonal ($P_{5,44}=2882$), is represented by a different number in the set.</li>
#<li>This is the only set of $4$-digit numbers with this property.</li>
#</ol><p>Find the sum of the only ordered set of six cyclic $4$-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.</p>
import math 
	
def isTriangle(n):
    res=(math.sqrt(1+8*n)-1)/2
    return res.is_integer() and res>0
    	
def isSquare(n):
	res=math.sqrt(n)
	return res.is_integer()
	
def isPentagonal(n):
	res=(math.sqrt(24*n+1)+1)/6
	return res.is_integer() and res>0
    
def isHexagonal(n):
	res=(math.sqrt(8*n+1)+1)/4
	return res.is_integer() and res>0
	
def isHeptagonal(n):
    res=(3+math.sqrt(9+40*n))/10
    return res.is_integer() and res>0
    
def isOctagonal(n):
	res=(2+math.sqrt(4+12*n))/6
	return res.is_integer() and res>0

def sol():
	lowerEdge=1000
	upperEdge=10000
	poly3=[]
	poly4=[]
	poly5=[]
	poly6=[]
	poly7=[]
	poly8=[]
	for n in range(lowerEdge,upperEdge):
		if(isTriangle(n)):
			poly3.append(str(n))
		if(isSquare(n)):
			poly4.append(str(n))
		if(isPentagonal(n)):
			poly5.append(str(n))
		if(isHexagonal(n)):
			poly6.append(str(n))
		if(isHeptagonal(n)):
			poly7.append(str(n))
		if(isOctagonal(n)):
			poly8.append(str(n))

	#the real trick is to create a list containing all our poly numbers. We must be sure not use the same type of polygon more than once.
	allPoly=[poly3, poly4, poly5, poly6, poly7, poly8]
	
	for type1 in allPoly:
		for p1 in type1:
			for type2 in allPoly:
				if(type1!=type2):
					for p2 in type2:
						if(p1[2]==p2[0] and p1[3]==p2[1]):
							for type3 in allPoly:
								if(type3!=type2 and type3!=type1):
									for p3 in type3:
										if(p2[2]==p3[0] and p2[3]==p3[1]):
											for type4 in allPoly:
												if(type4!=type3 and type4!=type2 and type4!=type1):
													for p4 in type4:
														if(p3[2]==p4[0] and p3[3]==p4[1]):
															for type5 in allPoly:
																if(type5!=type4 and type5!=type3 and type5!=type2 and type5!=type1):
																	for p5 in type5:
																		if(p4[2]==p5[0] and p4[3]==p5[1]):
																			for type6 in allPoly:
																				if(type6!=type5 and type6!=type4 and type6!=type3 and type6!=type2 and type6!=type1):
																					for p6 in type6:
																						if(p5[2]==p6[0] and p5[3]==p6[1]):
																							if(p6[2]==p1[0] and p6[3]==p1[1]):
																								return int(p1)+int(p2)+int(p3)+int(p4)+int(p5)+int(p6)

print(sol())